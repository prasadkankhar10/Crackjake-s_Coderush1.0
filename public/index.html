<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>CME Detector ‚Äî Space Edition</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap">
  <link rel="stylesheet" href="space.css">
  <link rel="stylesheet" href="solar.css">
</head>
<body>
  <div id="space-bg"></div>
  <div class="main-content">
    <div class="header">
      <div class="header-title">üöÄ CME Detector <span style="color:#00c3ff">‚Äî Space Edition</span></div>
    <div class="header-actions">
  <button id="refreshBtn" class="refresh-btn" title="Refresh data">‚Üª Refresh</button>
    </div>
    </div>

    <div class="card">
      <div class="card-header"><h3>Solar Wind Speed <small>(km/s)</small></h3><div class="card-meta">Live NOAA</div>
        <div style="margin-left:auto;display:flex;align-items:center;gap:8px;">
          <label style="font-size:0.85rem;color:var(--muted);display:flex;align-items:center;gap:6px;">Low threshold (km/s)
            <input id="thresholdToggle" type="number" min="100" max="5000" value="600" step="1" style="width:80px;margin-left:6px;padding:6px;border-radius:6px;background:#0b0b0b;color:#fff;border:1px solid rgba(255,255,255,0.06);" />
          </label>
          <div style="display:flex;gap:6px;align-items:center;margin-left:8px;">
            <button id="speedZoomIn" title="Zoom in" style="padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.04);color:var(--primary);">Ôºã</button>
            <button id="speedZoomOut" title="Zoom out" style="padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.04);color:var(--primary);">Ôºç</button>
            <button id="speedZoomReset" title="Reset zoom" style="padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.04);color:var(--muted);">Reset</button>
            <div id="speedWindowLabel" style="font-size:0.85rem;color:var(--muted);margin-left:8px;">Window: 800</div>
          </div>
        </div>
      </div>
      <div class="card-body"><canvas id="chart1"></canvas></div>
    </div>

    <div class="card">
      <div class="card-header"><h3>Magnetic Flux <small>(Bz, nT)</small></h3><div class="card-meta">IMF</div>
        <div style="margin-left:auto;display:flex;align-items:center;gap:8px;">
          <label style="font-size:0.85rem;color:var(--muted);display:flex;align-items:center;gap:6px;">Bz threshold (nT)
            <input id="bzThresholdInput" type="number" min="-1000" max="1000" value="-5" step="0.1" style="width:90px;margin-left:6px;padding:6px;border-radius:6px;background:#0b0b0b;color:#fff;border:1px solid rgba(255,255,255,0.06);" />
          </label>
          <div style="display:flex;gap:6px;align-items:center;margin-left:8px;">
            <button id="bzZoomIn" title="Zoom in" style="padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.04);color:var(--dust);">Ôºã</button>
            <button id="bzZoomOut" title="Zoom out" style="padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.04);color:var(--dust);">Ôºç</button>
            <button id="bzZoomReset" title="Reset zoom" style="padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.04);color:var(--muted);">Reset</button>
            <div id="bzWindowLabel" style="font-size:0.85rem;color:var(--muted);margin-left:8px;">Window: 800</div>
          </div>
        </div>
      </div>
      <div class="card-body"><canvas id="chart2"></canvas></div>
    </div>

    <div class="card">
      <div class="card-header"><h4>Detected CME Events</h4><div class="card-meta">Recent</div></div>
      <div class="card-body">
        <div id="events" class="events">Loading...</div>
      </div>
    </div>

    <div class="card">
      <div class="card-header"><h4>Prediction / Short-term Forecast</h4><div class="card-meta">Live</div></div>
      <div class="card-body">
        <div id="predictCard">Loading predictions...</div>
      </div>
    </div>
    <div style="text-align:center;color:#00c3ff88;font-size:1.1rem;margin-top:2rem;">
      <span>Data: NOAA SWPC | UI: Space Theme </span>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Optionally keep solar.js for CSS/HTML solar system overlay -->
  <script src="solar.js"></script>
  <script>
    const ctx1 = document.getElementById('chart1').getContext('2d');
    const ctx2 = document.getElementById('chart2').getContext('2d');
  let chart1, chart2;
  // threshold for coloring high-speed segments (default 600 km/s)
  let speedThreshold = 600;
  // threshold for coloring southward Bz segments (default -5 nT)
  let bzThreshold = -5;
  // window sizes for zooming (number of samples shown)
  let speedWindow = 800;
  let bzWindow = 800;

  async function fetchData() {
    try {
  const r = await fetch(`/latest?n=${Math.max(speedWindow,bzWindow,50)}`);
      const data = await r.json();
      const plasma = data.plasma || [];
      const mag = data.mag || [];

  // slice according to zoom window sizes (most recent last)
  const plasmaSlice = plasma.slice(-Math.max(speedWindow,50));
  const magSlice = mag.slice(-Math.max(bzWindow,50));
  const labelsPlasma = plasmaSlice.map(p => p.timeISO);
  const speeds = plasmaSlice.map(p => p.speed);

  const labelsMag = magSlice.map(m => m.timeISO);
  const bz = magSlice.map(m => m.bz);

      // read numeric input to update threshold (clamped)
      const thrEl = document.getElementById('thresholdToggle');
      const thrVal = thrEl ? Number(thrEl.value) : NaN;
      speedThreshold = Number.isFinite(thrVal) && thrVal > 0 ? Math.max(100, Math.min(5000, Math.round(thrVal))) : 600;

      // gradient used for high-speed segments (>= speedThreshold)
      const highSpeedGrad = ctx1.createLinearGradient(0,0,0,300);
      highSpeedGrad.addColorStop(0, '#7C3AED'); // Energy Jets purple
      highSpeedGrad.addColorStop(1, '#DC2626'); // Accent red

      const config1 = {
        type: 'line',
        data: { labels: labelsPlasma, datasets: [{
          label: 'Solar Wind Speed (km/s)',
          data: speeds,
          borderColor: '#00c3ff',
          backgroundColor: 'rgba(0,195,255,0.12)',
          tension: 0.25, pointRadius: 0, borderWidth: 2,
          // color segments purple->red when either endpoint is above threshold
          segment: {
            borderColor: ctx => {
              try {
                const y0 = ctx.p0 && ctx.p0.parsed ? ctx.p0.parsed.y : null;
                const y1 = ctx.p1 && ctx.p1.parsed ? ctx.p1.parsed.y : null;
                if ((y0 != null && y0 >= speedThreshold) || (y1 != null && y1 >= speedThreshold)) return highSpeedGrad;
              } catch(e){}
              return '#00c3ff';
            }
          }
        }]},
        options: { responsive: true, plugins: { legend: { labels: { color: '#00c3ff' } } },
          scales: { x: { ticks: { color: '#e0e6f6', maxTicksLimit: 12 } }, y: { ticks: { color: '#e0e6f6' } } } }
      };

      // read Bz threshold input
      const bzEl = document.getElementById('bzThresholdInput');
      const bzVal = bzEl ? Number(bzEl.value) : NaN;
      bzThreshold = Number.isFinite(bzVal) ? Math.max(-1000, Math.min(1000, bzVal)) : -5;

      // gradient used for southward Bz segments (negative values)
      const southGrad = ctx2.createLinearGradient(0,0,0,300);
      southGrad.addColorStop(0, '#00AFFF'); // Starburst cyan
      southGrad.addColorStop(1, '#DC2626'); // Accent red

      const config2 = {
        type: 'line',
        data: { labels: labelsMag, datasets: [{
          label: 'IMF Bz (nT)',
          data: bz,
            borderColor: '#FFB347',
            backgroundColor: 'rgba(255,179,71,0.10)',
            tension: 0.25, pointRadius: 0, borderWidth: 2,
            segment: {
              borderColor: ctx => {
                try {
                  const y0 = ctx.p0 && ctx.p0.parsed ? ctx.p0.parsed.y : null;
                  const y1 = ctx.p1 && ctx.p1.parsed ? ctx.p1.parsed.y : null;
                  if ((y0 != null && y0 <= bzThreshold) || (y1 != null && y1 <= bzThreshold)) return southGrad;
                } catch(e){}
                return '#FFB347';
              }
            }
        }]},
        options: { responsive: true, plugins: { legend: { labels: { color: '#FFB347' } } },
          scales: { x: { ticks: { color: '#e6f3fb', maxTicksLimit: 12 } }, y: { ticks: { color: '#e6f3fb' } } } }
      };

  // recreate chart1 to ensure segment callback uses current threshold/gradient
      try { if (chart1) { chart1.destroy(); chart1 = null; } } catch(e){}
      chart1 = new Chart(ctx1, config1);
  if (!chart2) chart2 = new Chart(ctx2, config2); else { chart2.destroy(); chart2 = new Chart(ctx2, config2); }

  // update window labels
  const swLabel = document.getElementById('speedWindowLabel'); if (swLabel) swLabel.innerText = `Window: ${speedWindow}`;
  const bzLabel = document.getElementById('bzWindowLabel'); if (bzLabel) bzLabel.innerText = `Window: ${bzWindow}`;
    } catch (err) { console.error(err); }
  }

    async function fetchEvents() {
      const r = await fetch('/events');
      const j = await r.json();
      // accept either an array response or an object { detections: [...] }
      let events = Array.isArray(j) ? j : (Array.isArray(j.detections) ? j.detections : []);
      const el = document.getElementById('events');
      if (!events.length) { el.innerHTML = '<i>No events detected (yet)</i>'; return; }

      // map intensity when missing (same logic as server heuristics)
      const mapIntensity = (speed) => {
        if (speed == null) return 'Unknown';
        if (speed > 3000) return 'Very Strong';
        if (speed > 1500) return 'Strong';
        if (speed > 1200) return 'Moderate';
        if (speed > 400) return 'Mild';
        return 'Nominal';
      };
      const badgeClassFor = (intensity) => {
        if (!intensity) return 'info';
        const s = String(intensity).toLowerCase();
        if (s.includes('very') || s.includes('strong') || s.includes('crit')) return 'crit';
        if (s.includes('moderate') || s.includes('mild')) return 'warn';
        return 'info';
      };

      // normalize fields for rendering
      const normalized = events.map(e => ({
        id: e.id || `${e.timeISO || 'unknown'}_${Math.round(e.speed||0)}`,
        timeISO: e.timeISO || e.time || 'Unknown time',
        speed: (e.speed == null ? (e.speed === 0 ? 0 : null) : Math.round(e.speed)),
        density: (e.density == null ? (e.density === 0 ? 0 : null) : Math.round(e.density)),
        bz: (e.bz == null ? (e.bz === 0 ? 0 : null) : Math.round(e.bz)),
        deltaV: e.deltaV != null ? e.deltaV : (e.delta_v ?? null),
        forecast_arrival_hours: e.forecast_arrival_hours ?? e.arrival_hours ?? null,
        intensity: e.intensity ?? mapIntensity(e.speed)
      }));

      el.innerHTML = normalized.slice().reverse().map(e => {
        const badgeCls = badgeClassFor(e.intensity);
        return `
        <div class="evt">
          <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;">
            <strong>${e.timeISO}</strong>
            <span class="badge ${badgeCls}">${e.intensity}</span>
          </div>
          <div style="margin-top:6px;">
            <span style="color:var(--primary)">speed:</span> ${e.speed ?? 'n/a'} km/s ¬∑
            <span style="color:var(--dust)">density:</span> ${e.density ?? 'n/a'} p/cm¬≥ ¬∑
            <span style="color:var(--accent)">bz:</span> ${e.bz ?? 'n/a'} nT
          </div>
          <div style="color:rgba(0,170,255,0.6);margin-top:6px;">
            ŒîV: ${e.deltaV ?? 'n/a'} km/s ¬∑ arrival: ${e.forecast_arrival_hours ?? 'n/a'} h
          </div>
        </div>`;
      }).join('');
    }

    async function refreshAll() {
  document.getElementById('refreshBtn').classList.add('loading');
  await fetchData();
  await fetchEvents();
  await fetchPredict();
  document.getElementById('refreshBtn').classList.remove('loading');
    }

    refreshAll();
    setInterval(refreshAll, 60*1000);
    // Wire up refresh button
    document.getElementById('refreshBtn').addEventListener('click', async (e) => {
      e.currentTarget.disabled = true;
      await refreshAll();
      e.currentTarget.disabled = false;
    });

    // Prediction UI: fetch /predict and render into the Predict card
    async function fetchPredict() {
      const el = document.getElementById('predictCard');
      if (!el) return;
      try {
        const r = await fetch('/predict');
        const j = await r.json();
        const quick = j.quick || {};
        const fc = j.forecast || { speed: [], bz: [] };
        const score = quick.score ?? 'n/a';
        const label = quick.severity_label ?? 'Nominal';
        const cls = quick.severity_class ?? 'info';
        const anomaly = quick.anomaly?.isAnomaly ? quick.anomaly.triggers.map(t => `${t.metric}:${t.z}`).join(', ') : '';
        const nextSpeed = fc.speed && fc.speed.length ? fc.speed[0] : 'n/a';
        const nextBz = fc.bz && fc.bz.length ? fc.bz[0] : 'n/a';

        // compute badge styles to ensure high contrast on dark background
        let badgeStyle = '';
        if (cls === 'crit') badgeStyle = 'background: rgba(220,38,38,0.95); color: #fff;';
        else if (cls === 'warn') badgeStyle = 'background: rgba(255,179,71,0.95); color: #041014;';
        else badgeStyle = 'background: rgba(0,170,255,0.95); color: #041014;';

  el.innerHTML = `
          <div style="display:flex;flex-direction:row;flex-wrap:wrap;gap:12px;align-items:center;color:#000;">
            <div style="min-width:160px;">
              <div style="font-weight:700;color:var(--muted);font-size:0.95rem;">Quick Score</div>
              <div style="display:flex;align-items:center;gap:10px;margin-top:6px;">
                <div class="badge" style="${badgeStyle}font-size:0.95rem;padding:8px 12px;border-radius:10px;">${label}</div>
                <div style="font-weight:700;color:#000;">${score}</div>
              </div>
            </div>
            <div style="min-width:220px;">
              <div style="font-weight:700;color:var(--muted);font-size:0.95rem;">Next step forecast</div>
              <div style="margin-top:6px;color:#000;">Speed: <span style="color:var(--primary)">${nextSpeed}</span> km/s ¬∑ Bz: <span style="color:var(--dust)">${nextBz}</span> nT</div>
            </div>
            <div style="flex:1;min-width:160px;">
              <div style="font-weight:700;color:var(--muted);font-size:0.95rem;">Details</div>
              <div style="margin-top:6px;color:#000;font-size:0.9rem;">Anomaly: ${anomaly || 'none'}</div>
            </div>
            <div style="width:100%;color:#000;font-size:0.8rem;margin-top:8px;">Updated ${new Date().toLocaleTimeString()}</div>
          </div>`;
        // add download controls (format selector, limit, and download + spinner)
        el.innerHTML += `
          <div style="margin-top:10px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
            <label style="color:var(--muted);font-size:0.85rem;">Format:
              <select id="exportFormat" style="margin-left:6px;padding:6px;border-radius:8px;background:#0b0b0b;color:#fff;border:1px solid rgba(255,255,255,0.06);">
                <option value="csv">CSV</option>
                <option value="json">JSON</option>
              </select>
            </label>
            <label style="color:var(--muted);font-size:0.85rem;">Limit:
              <input id="exportLimit" type="number" min="1" max="50000" value="500" style="width:90px;margin-left:6px;padding:6px;border-radius:8px;background:#0b0b0b;color:#fff;border:1px solid rgba(255,255,255,0.06);" />
            </label>
            <button id="downloadDetectionsBtn" style="background:linear-gradient(90deg,var(--primary),var(--energy));border:0;color:white;padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:700;">Download</button>
            <div id="downloadSpinner" style="display:none;margin-left:6px;align-items:center;font-size:0.9rem;color:var(--muted);">Preparing<span id="dot">.</span></div>
          </div>`;
        const dbtn = document.getElementById('downloadDetectionsBtn');
        if (dbtn) dbtn.addEventListener('click', async () => {
          const fmt = document.getElementById('exportFormat').value || 'csv';
          const lim = Number(document.getElementById('exportLimit').value) || 500;
          await downloadExport('detections', fmt, lim);
        });
        // small animated dot for spinner text
        (function(){ const ds = document.getElementById('downloadSpinner'); const dot = document.getElementById('dot'); if (!ds || !dot) return; let i=0; setInterval(()=>{ i=(i+1)%4; dot.innerText='.'.repeat(i); },400); })();
      } catch (err) {
        el.innerText = 'Predict: offline';
      }
    }

    // helper to trigger download from /export with spinner and streaming
    async function downloadExport(type='detections', format='csv', limit=500) {
      const spinner = document.getElementById('downloadSpinner');
      if (spinner) spinner.style.display = 'inline-flex';
      const url = `/export?format=${encodeURIComponent(format)}&limit=${encodeURIComponent(limit)}`;
      try {
        // For JSON small responses we can simply navigate to URL to prompt download
        if (format === 'json') {
          // open in new tab to let browser handle JSON download
          window.open(url, '_blank');
          return;
        }

        // For CSV we stream the response as a blob and trigger download to keep spinner until ready
        const resp = await fetch(url);
        if (!resp.ok) throw new Error('Export failed: '+resp.status);
        // stream to blob (works for moderate-large files without fully building strings)
        const reader = resp.body.getReader();
        const chunks = [];
        let received = 0;
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          chunks.push(value);
          received += value.length;
        }
        const blob = new Blob(chunks, { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const urlb = URL.createObjectURL(blob);
        link.href = urlb;
        link.download = 'detections.csv';
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(urlb);
      } catch (err) {
        console.error('Download error', err);
        alert('Export failed: ' + (err && err.message ? err.message : 'unknown'));
      } finally {
        if (spinner) spinner.style.display = 'none';
      }
    }

  // call predictions on each refresh and at regular interval (shows live with delay)
  fetchPredict();
  setInterval(fetchPredict, 30*1000);
  // listen for threshold input changes to update chart coloring immediately
  const toggleEl = document.getElementById('thresholdToggle');
  if (toggleEl) toggleEl.addEventListener('input', async () => { await fetchData(); });
  const bzInput = document.getElementById('bzThresholdInput');
  if (bzInput) bzInput.addEventListener('input', async () => { await fetchData(); });
  // zoom controls
  const speedIn = document.getElementById('speedZoomIn');
  const speedOut = document.getElementById('speedZoomOut');
  const speedReset = document.getElementById('speedZoomReset');
  if (speedIn) speedIn.addEventListener('click', async () => { speedWindow = Math.max(50, Math.floor(speedWindow/1.5)); await fetchData(); });
  if (speedOut) speedOut.addEventListener('click', async () => { speedWindow = Math.min(50000, Math.ceil(speedWindow*1.5)); await fetchData(); });
  if (speedReset) speedReset.addEventListener('click', async () => { speedWindow = 800; await fetchData(); });

  const bzIn = document.getElementById('bzZoomIn');
  const bzOut = document.getElementById('bzZoomOut');
  const bzReset = document.getElementById('bzZoomReset');
  if (bzIn) bzIn.addEventListener('click', async () => { bzWindow = Math.max(50, Math.floor(bzWindow/1.5)); await fetchData(); });
  if (bzOut) bzOut.addEventListener('click', async () => { bzWindow = Math.min(50000, Math.ceil(bzWindow*1.5)); await fetchData(); });
  if (bzReset) bzReset.addEventListener('click', async () => { bzWindow = 800; await fetchData(); });
  </script>
</body>
</html>
